<!doctype html>
<html>
    {{ with . }}
		<title>doji [{{ .Key }}]</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <meta name="referrer" content="none" />
        <style>
         body {
             width: 700px;
             height: 700px;
             margin: 1em auto 0 auto;
             position: relative;
			 font-family: "Open Sans", "Nono Sans", Tahoma, Geneva, sans-serif;
         }

		 code {
			 font-family: Consolas, Monaco, monospace, monospace;
			 color: #262;
			 display: inline-block;
			 word-break: break-all;
		 }

         .box { border: 2px solid black; }

		 #vid, #msgs, #opts, #reqs { position: absolute; }

		 #vid {
			 top: 0;
			 left: 0;
			 width: 696px;
			 height: 296px;
			 background: black;
		 }
		 #vid video {
			 display: block;
			 margin: auto;
			 height: 100%;
			 max-width: 100%;
		 }
		 #vid #title {
			 position: absolute;
			 top: 4px;
			 right: 4px;
			 padding: 4px;
			 display: none;
			 background: rgba(255,255,255, 0.5);
			 color: black;
		 }
		 #vid:hover #title { display: block; }

		 #msgs {
			 top: 300px;
			 left: 0;
			 width: 296px;
			 height: 396px;
			 background: #bef;
		 }
		 #msgs > .hl { background: #8ad }

		 #opts {
			 top: 300px;
			 left: 300px;
			 width: 396px;
			 height: 296px;
			 background: #fbe;
		 }
		 #opts > .hl { background: #d8a; }

		 #reqs {
			 top: 600px;
			 left: 300px;
			 width: 396px;
			 height: 96px;
			 background: #feb;
			 display: flex;
			 flex-direction: column;
		 }
		 #reqs > canvas {
			 width: 100%;
			 height: 18px;
			 border-bottom: 1px solid #da8;
		 }

		 ::-webkit-scrollbar { width: 8px; }
		 ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
		 ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.25); }

		 ul.list, .text {
			 overflow-x: hidden;
			 overflow-y: auto;
			 list-style: none;
			 padding: 0;
			 margin: 0;
		 }
		 #opts ul.list li { word-break: break-all; }

		 ul.hlist {
			 overflow-x: auto;
			 overflow-y: hidden;
			 list-style: none;
			 display: flex;
			 padding: 0;
			 margin: 0;
		 }
		 ul.hlist > li {
			 display: inline-table;
			 border-right: 1px solid black;
			 font-size: 15px;
			 padding: 0 4px;
			 margin: 0;
		 }

		 .text { padding: 0.5em; }
		 .text h1, .text h2, text h3, .text h4, .text hr {
			 margin: 0;
			 border-width: 0;
			 border-bottom: 1px solid rgba(0,0,0,0.5);
			 font-variant: small-caps;
		 }
		 .text h1 { font-size: 120%; }
		 .text h2 { font-size: 110%; }
		 .text h3 { font-size: 105%; }
		 .text h4 { font-size: 100%; }
		 .text hr { margin-bottom: 1em; border-style: dashed; }
		 .text p, .text li, .text dd { margin-top: 8px; text-align: justify; }
		 .text a { color: #039; }
		 .text code {
			 background: rgba(50,200,50,0.1);
			 padding: 2px 4px;
			 border-radius: 2px;
		 }

		 .box.bottom, .box.top { position: relative; }
		 .box.top ul, .box.bottom ul { max-height: calc(100% - 18px); }
		 .box.top.bottom ul.list, .box.top .text, .box.bottom .text {
			 max-height: calc(100% - 34px);
		 }
		 .box.top ul.list, .box.top .text  { margin-top: 18px; }
		 .box.bottom ul.list, .box.bottom .text  { margin-bottom: 18px; }

		 .interact {
			 position: absolute;
			 left: 0;
			 right: 0;
			 border: 0 solid black;
			 padding: 0;
			 background: white;
			 width: 100%;
			 height: 17px;
		 }
		 .interact.bottom { border-top-width: 1px; bottom: 0; }
		 .interact.top { border-bottom-width: 1px; top: 0; }

		 .interact, #opts > ul > li {
			 -webkit-user-select: none; /* Safari */
			 -moz-user-select: none; /* Firefox */
			 -ms-user-select: none; /* IE10+/Edge */
			 user-select: none; /* Standard */
		 }

		 #msgs > ul.hlist, #msgs > ul.list li:nth-child(even) { background: #8ad; }
		 #opts > ul.hlist, #opts > ul.list li:nth-child(even) { background: #d8a; }

		 ul.choices > li { cursor: pointer; }
		 ul.choices > li:hover { background: rgba(0,0,0,.2) !important; }
		 ul > .choice { background: rgba(0,0,0,0.2); }

		 ul#sets > li.loaded { font-weight: bold; }
		 ul#set > #set-filter {
			 width: 100%;
			 border: 0px solid black;
			 height: 20px;
			 border-bottom-width: 1px;
		 }

		 #settings {
			 padding: 0;
			 border-collapse: collapse;
			 width: 100%;
		 }
		 #settings tr {
			 border-bottom: 1px solid #d8a;
		 }
		 #settings td {
			 width: calc(50% - 10px);
			 padding: 2px;
		 }
		 #settings td:nth-child(2) { text-align: right; }
		 #settings tr:hover { background: rgba(0,0,0,1.) !important; }

		 .dlds {

		 }

         @media only screen and (max-width: 700px) {
			 body, html {
				 height: unset;
				 border-width: 0;
				 width: 100%;
				 min-width: initial;
				 margin: 0;
				 padding: 0;
			 }

			 #vid, #msgs, #opts, #reqs {
				 position: relative;
				 width: 100%;
				 height: auto;
				 min-height: 50px;
				 max-height: 300px;
				 top: unset;
				 left: unset;
			 }
         }
        </style>
        <body class="box">
            <div id="vid" class="box">
				<span id="title">doji v2</span>
                <video id="video" controls preload>
                    Oh no! This browser doesn’t support HTML video.
                </video>
            </div>

			<div id="msgs" class="box top bottom">
				<ul id="usr" class="interact hlist top"></ul>
				<ul id="msg" class="list"></ul>
				<input type="text"
					   class="interact prompt bottom"
					   id="prompt"
					   disabled
					   autofocus />
			</div>

			<div id="opts" class="box bottom">
				<ul class="interact hlist choices bottom">
					<li id="videos-b">videos</li>
					<li id="queue-b">queue</li>
					<li id="sets-b">sets</li>
					<li id="settings-b">settings</li>
					<li id="help-b">help</li>
					<li id="info-b">info</li>
				</ul>

				<ul id="videos" class="list choices"></ul>
				<ul id="queue" class="list choices"></ul>
				<ul id="sets" class="list choices">
				</ul>
				<table id="settings"><tbody id="setbody">
				</tbody></table>
				<div id="help" class="text">
					<h1>Built-in Manual</h1>

					<h2>General Usage</h2>
					<p>
						doji is used in Browsers with HTML5 and ES6 compatibility. If
						you can read this manual, everything is probably ok.
					</p>
					<p>
						The UI consist of the following main elements:
					</p>
					<ul>
						<li>
							<strong>Black box, top:</strong>
							This is the <em>video box</em>. Besides a
							<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/HTML5_video">HTML5 video</a>,
							nothing should be found here.
						</li>
						<li>
							<strong>Blue box, bottom left:</strong>
							This is the <em>message box</em>. Messages
							about the state of the room will be
							displayed here.
						</li>
						<li>
							<strong>Pink box, center right:</strong>
							This is the <em>options box</em>.
							It contains multiple tabs (you're currently
							in the <em>help</em> tab) that let you operate
							doji. For more details see <em>FQA</em>.
						</li>
						<li>
							<strong>Yellow box, bottom right:</strong>
							This is the <em>downloads box</em>.
							You'll how far the currently requested videos
							have been downloaded.
						</li>
					</ul>


					<h2>FQA <sup>(Frequently Questioned Answers)</sup></h2>
					<dl>
						<dt><em>How do I play a video?</em></dt>
						<dd>
							Go to the <em>videos</em> tab, click on a
							file name. This should automatically load
							the video, but <strong>not</strong> start
							playing it. The user must to this manually.
						</dd>

						<dt><em>How do I add a video?</em></dt>
						<dd>
							Just drop any URL (without any commands or comments) into the message box.
							A message should pop up mentioning that you've added the video, and
						</dd>

						<dt><em>Why aren't videos played immediately?</em></dt>
						<dd>
							Instead of directly connecting to the forign
							site, doji downloads the video you requested
							to it's server, and then hosts this video for
							everyone in the room. It is this process of
							downloading that take a short while.
						</dd>

						<dt><em>How do I remove a video?</em></dt>
						<dd>
							See <code>/delete</code> command.
						</dd>

						<dt><em>What is the queue?</em></dt>
						<dd>
							The queue is a list of videos which will be
							automatically started as soon as the current
							video finishes. New videos are added to the end,
							the next video is taken from the top.
							<br/>
							See <code>/next</code>, <code>/pop</code>,
							<code>/enqueue</code>.
						</dd>

						<dt><em>What are sets?</em></dt>
						<dd>
							<q>Sets</q> let users automatically add or remove
							related videos (such as a playlist, series, etc.)
							that have been set up by the server administrator.
							<br/>
							Note that if a server has no sets, the <q>sets</q>
							tab is not displayed.
						</dd>
					</dl>

					<p>
						More questions and answers can be found on doji's
						<a href="https://zge.us.to/proj/doji/">homepage</a>.
					</p>

					<h2>Commands</h2>
					<p>
						All commands are entered into the chat box
						(white field under the messages, in the blue
						area). doji recognizes a command when it's
						prefixed with a forwards slash (<code>/</code>),
					    and interprets all the following words, delemitered
					    by one or more whitespaces as it's arguments.
					</p>
					<p>
						Most <q>more complex</q> interaction with doji is done
						using these commands, but most users can comfortably use
						it without any knowledge about these.
					</p>
					<p>
						For everyday options, use the settings tab (right next to
						this one). Note that everything that can be done there, can
						also be achieved using commands.
					</p>
					<p>
						The following list gives an overfiew of all the supported
						commands:
					</p>
					<dl>
						<dt><code>/stats</code>, <code>/stat</code></dt>
						<dd>Print the current aggregate file size of all
							the loaded videos.</dd>

						<dt><code>/update</code>, <code>/u</code></dt>
						<dd>Force-refresh the list of all videos in the
							current room for all users.</dd>

						<dt><code>/format [arg]</code>, <code>/f</code></dt>
						<dd>Automatically skip to the next video in the
							queue, without waiting to finish the current one.</dd>

						<dt><code>/next</code>, <code>/n</code></dt>
						<dd>Skip the current video in the queue, and
						    start playing the next one.</dd>

						<dt><code>/volume [arg]</code> (local)</dt>
						<dd>Set the volume of the video player. <code>0</code>
							mutes the steam, <code>1</code> is the loudest.</dd>

						<dt><code>/search [arg]</code> (local)</dt>
						<dd>Only display all the sets that match
							<code>[arg]</code> as a regular expression.</dd>
					</dl>
				</div>
				<div id="info" class="text">
					<h1>doji, v2</h1>
					<p>
						<em>doji</em> (<a target="_blank" rel="noopener noreferrer" href="https://en.wiktionary.org/wiki/%E3%81%A9%E3%81%86%E3%81%98">jap.</a> <q>どうじ</q>,
						<em>the same event</em>) is a video
						synchronizing utility, allowing it's users to watch
						the same video at the same time, desipte not being in the
						same place.
					</p>
					<h2>Technical Info</h2>
					<p>
						Instead of directly connecting the user to thrid-party sites, potentially running
						<a target="_blank" rel="noopener noreferrer" href="https://www.gnu.org/philosophy/javascript-trap.html">harmful code</a>, doji uses
						<a target="_blank" rel="noopener noreferrer" href="https://rg3.github.io/youtube-dl/"><code>youtube-dl</code></a> to
						first download the video onto the server, then host it directly to it's users.
					</p>
					<p>
						Besides protecting the user from potentially dangerous actors, <code>youtube-dl</code> provides a wide
						range of <a target="_blank" rel="noopener noreferrer" href="https://rg3.github.io/youtube-dl/supportedsites.html">supported sites</a>, which are
						all also accesible to doji users. No third-party vendor is needed to run doji.
					</p>
					<h2>Legal</h2>
					<p>
						As <a target="_blank" rel="noopener noreferrer" href="https://www.gnu.org/philosophy/free-sw.en.html">Free Software</a>,
						the source code is public and may be freely distrubted, under the under the
						<a target="_blank" rel="noopener noreferrer" href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPL 3</a> license.
					</p>
					<p>
						The source can be found <a target="_blank" rel="noopener noreferrer" href="https://zge.us.to/git/doji/">here</a> and is
						mirrored on <a target="_blank" rel="noopener noreferrer" href="https://github.com/phikal/doji">GitHub</a>. Issues and
						suggestions can be reported on GitHub or by sending an Email to the
						<a href="mailto:philip@warpmail.net">developer</a>.
					</p>
					<hr />
					<h1>Changelog</h1>
					<h2>Version 2.0</h2>
					<ul>
						<li>UI redisign: More flexible backend and added <q>downloads</q> box.</li>
						<li>Queues: Let videos be played after one another, without manually having to select them.</li>
						<li>Sets: Automatically add and remove a set (series, queues)</li>
						<li>Changed video list box into general <q>information</q> box.</li>
						<li>Added Settings, <em>Manual</em> (Help) and Info page.</li>
					</ul>
				</div>
			</div>

			<div id="reqs" class="box"></div>
		</body>

        <script>
         "use strict";
         const moffset = 0.38196601125; // maximal playback offset (sec)
         const rwait = 50; // ms wait for website to react
         const scint = 20000; // ms to wait between status requests
         const bufwait = 500; // ms to wait between buffering checks

		 function getElementById(id) {
			 var elem = document.getElementById(id);
			 if (elem == null)
				 throw "non-existent element \"" + id + "\"";
			 return elem;
		 }

         const video = getElementById("video");
         const users = getElementById("usr");
         const prompt = getElementById("prompt");
         const log = getElementById("msg");
         const videos = getElementById("videos");
         const queue = getElementById("queue");
		 const sets = getElementById("sets");
		 const requests = getElementById("reqs");

		 function getCookie(name) {
			 var value = "; " + document.cookie;
			 var parts = value.split("; " + name + "=");
			 if (parts.length == 2) return parts.pop().split(";").shift();
		 }

         const user = document.cookie.replace(/(?:(?:^|.*;\s*)user\s*\=\s*([^;]*).*$)|^.*$/, "$1") ||
                      window.prompt("Username", (Math.random() + 1).toString(36).substring(7));
         document.cookie = "user=" + user + ";path=/";

		 const conf = JSON.parse(getCookie("conf") || "{}");

		 const menus = [ "videos", "queue", "sets", "settings", "help", "info" ];
		 function choose_menu(id) {
			 document.cookie = "tab=" + id;
			 menus.map(m => {
				 getElementById(m).style.display = (m === id) ? "" : "none";
				 if (m === id)
					 getElementById(m + "-b").classList.add("choice");
				 else
					 getElementById(m + "-b").classList.remove("choice");
			 });
		 }

		 menus.map(m => getElementById(m + "-b").onclick = () => choose_menu(m));
		 choose_menu(getCookie("tab") || "videos");

         function jump_to(sec) {
             if (sec === undefined || sec < 0)
                 return;

			 if (remote) {
				 setTimeout(_ => jump_to(sec), 100);
				 return;
			 }

             function jump() {
                 if (Math.abs(sec - video.currentTime) > moffset)
					 video.currentTime = sec;

				 /* if (video.readystate > 2) {
					if (video.playing)
					video.play();
					else
					video.pause();
					}*/

				 remote = false;
             }
             function check() {
                 var buf = video.seekable;
                 for (var i = 0; i < buf.length; i++) {
                     if (buf.start(i) < sec && buf.end(i) > sec) {
						 jump(sec);
					 } else setTimeout(check, bufwait);
                 }
             }
             check();
         }

         function load_video(vid) {
			 if (!vid) return;
             var parser = document.createElement('a');
             parser.href = video.src;
			 var ovid = vid;
             vid = "./d" + window.location.pathname + "/" + vid;
             if (vid != "." + parser.pathname) { // TODO: make cleverer
                 video.src = vid;
                 video.load();
                 video.currentTime = 0;
				 getElementById("title").innerText = ovid;
				 video.pause();
				 remote = false;
             }
         }

		 var sfilter = false;
         function exec_cmd(cmd) {
             var matches = cmd.match(/^\/(\w+)(?:\s+(.+)\s*)?/);
             if (!matches)
                 return false;
             var arg = "";
             if (matches.length > 2)
                 arg = matches[2];
             switch (matches[1]) {
                 case "volume":
                     if (arg) {
                         video.volume = arg;
                         log_msg({
                             type: "event",
                             msg: "<em>set volume to " + (arg * 100) + "%</em>"
                         });
                     }
                     break;
				 case "search":
					 sfilter = arg || new RegExp(arg, "i");
					 send({ type: "status" })
					 break;
             }
             return true;
         }

         function load_status(data) {
			 console.log(data);

             while(videos.firstChild)
                 videos.removeChild(videos.firstChild);
             if (data.vids)
                 data.vids.map(v => {
                     var vid = document.createElement("li");
                     vid.appendChild(document.createTextNode(v));
                     vid.onclick = _ => send({
                         type: conf.queue ? "push" : "select",
                         msg: v
                     });
                     videos.appendChild(vid);
                 });

			 if (data.queue) {
				 while(queue.firstChild)
					 queue.removeChild(queue.firstChild);
				 data.queue.map((d, i) => {
					 var que = document.createElement("li");
                     que.appendChild(document.createTextNode(d));
                     que.onclick = _ => send({
						 type: "pop",
						 val: i,
					 });
                     queue.appendChild(que);
				 })
			 }

			 if (data.sets) {
				 while(sets.firstChild)
					 sets.removeChild(sets.firstChild);
                 data.sets.sort().map(s => {
					 if (sfilter && !s.match(sfilter))
						 return;

                     var vid = document.createElement("li");
                     vid.appendChild(document.createTextNode(s));
					 if (s in data.lsets)
						 vid.classList.add("loaded");
                     vid.onclick = _ => send({
						 type: "load",
						 msg: s
					 });
                     sets.appendChild(vid);
                 });
			 }

             while(users.firstChild)
                 users.removeChild(users.firstChild);
             for (var u in data.users) {
                 var tag = document.createElement("li");
                 tag.appendChild(document.createTextNode(u));
                 if (u == user)
                     tag.classList.add("choice");
                 users.appendChild(tag);
             }

		 	 if (data.reqs) {
				 while(reqs.firstChild)
					 reqs.removeChild(reqs.firstChild);
				 data.reqs.map(r => {
			 		 console.log(r);

					 var canvas = document.createElement("canvas");
					 var ctx = canvas.getContext("2d");
					 ctx.fillStyle = "#da8";
					 ctx.fillRect(0, 0, canvas.width  * r.progress, canvas.height);
					 ctx.fillStyle = "#000";
					 ctx.font = "14px monospace";
					 ctx.fillText(r.url, 2, 15);
					 reqs.appendChild(canvas);

					 /* var tag = document.createElement("li");
					  * tag.appendChild(document.createTextNode(r.url));
					  * tag.style.background = "url(" + canvas.toDataURL() + ")";
					  * reqs.appendChild(tag);*/
				 });
			 }

			 if (!remote) {
				 remote = true;

				 load_video(data.playing);
				 jump_to(data.progress);

				 console.log(video.paused, data.paused);
				 if (video.paused && !data.paused)
					 video.play();
				 else if (!video.paused && data.paused)
					 video.pause();
				 remote = false;
			 }
         }

		 var lastmsg;
         function log_msg(msg) {
             var l = document.createElement("li");
             l.classList.add(msg.type);
             switch(msg.type) {
                 case "talk":
                     l.innerHTML =  "<b>" + msg.from + ":</b> " +
									msg.msg;
                     break;
                 case "pause":
                     l.innerHTML = "<b>" + msg.from + "</b> " +
                                   "paused the video";
                     break;
                 case "play":
                     l.innerHTML = "<b>" + msg.from + "</b> " +
                                   "started playing the video";
                     break;
                 case "seek":
                     var s = msg.val;
                     var hour = ~~(s / 3600),
                         min  = ("0" + ~~(s / 60)).slice(-2),
                         sec  = ("0" + (s % 60)).slice(-2);
                     l.innerHTML = "<b>" + msg.from + "</b> moved to " +
									(hour == 0 ? "" : hour + ":") +
                                   min + ":" + sec;
                     break;
                 case "select":
                     l.innerHTML = "<b>" + msg.from + "</b> " +
								   "selected new video: <code>" +
                                   msg.msg + "</code>";
                     break;
				 case "push":
					 l.innerHTML = "<b>" + msg.from + "</b> " +
								   "added new video to queue: <code>" +
                                   msg.msg + "</code>";
					 break;
				 case "load":
					 l.innerHTML = "<b>" + msg.from + "</b> " +
									(msg.data ? "unloaded" : "loaded") +
								   " new set: <code>" +
                                   msg.msg + "</code>";
					 break;
                 case "event":
                 case "request":
                     l.innerHTML = msg.msg;
                     break;
                 default:
                     return;
             }
             log.appendChild(l);
             log.scrollTop = log.scrollHeight;
         }
         var remote = true, seeking = false; /* hacked asf */
         const socket = new WebSocket(location.href.replace(/http/, "ws") +
                                      "/socket");

		 function send(msg) {
			 if (socket.readyState < 1)
				 setTimeout(0.1, _ => send(msg));
			 else
				 socket.send(JSON.stringify(msg));
		 }

		 const save = _ => document.cookie = "conf=" +
											 JSON.stringify(conf) +
											 ";  path=/";
		 const setbody = getElementById("setbody");
		 function addconf(name, type, run) {
			 var row = document.createElement("tr");

			 var lab = document.createElement("td");
			 lab.innerText = name;
			 row.appendChild(lab);

			 var opt = document.createElement("td");
			 var input = document.createElement("input");
			 input.type = type;
			 opt.appendChild(input);
			 row.appendChild(opt);

			 setbody.appendChild(row);

			 run = run || (_ => 0);
			 name = name.replace(/[^a-z]/gi, "").toLowerCase();
			 switch (type) {
				 case "checkbox":
					 input.onclick = _ => {
						 conf[name] = input.checked;
						 save();
						 run();
					 };
					 input.checked = conf[name];
					 break;
				 default:
					 input.onclick = _ => {
						 conf[name] = input.value
						 save();
						 run();
					 };
					 input.value = conf[name];
					 break;
			 }
		 }

		 addconf("Queue?", "checkbox");

		 // events
         socket.onmessage = e => {
             remote = true;
             var msg = JSON.parse(e.data);
             var timestamp = new Date().toLocaleTimeString();
             switch(msg.type) {
                 case "pause":
                     if (msg.from != user) {
						 video.pause();
						 jump_to(msg.val);
					 }
					 if (msg.msg)
						 log_msg("Paused for " + msg.msg);

                     break;
                 case "play":
                     if (msg.from != user && video.paused) {
						 video.play();
						 jump_to(msg.val);
					 }
                     break;
                 case "seek":
					 if (lastmsg.type == "seek" || msg.from == user)
						 break;
					 jump_to(msg.val);
                     break;
                 case "select":
					 video.pause();
                     load_video(msg.msg);
                     break;
				 case "load":
					 for (var i = 0; i < sets.children.length; i++) {
						 if (sets.children[i].innerText == msg.msg) {
							 sets.children[i].classList.toggle("loaded");
							 break;
						 }
					 }
					 log_msg("Toggled set " + msg.msg)
					 break;
				 case "status":
					 load_status(msg.data);
					 break;
			 }
			 if (msg)
				 lastmsg = msg;
			 log_msg(msg);
			 setTimeout(_ => remote = false, rwait);
         };

         // input events
         prompt.onkeypress = e => {
			 if (e.key == "Enter" && prompt.value) {
                 if (!exec_cmd(prompt.value))
                     send({
                         type: "talk",
                         msg: prompt.value.trim()
                     });
                 prompt.value = "";
             }
         };

         // window events
         window.onbeforeunload = _ => socket.close();

         // setup
         socket.onerror = err => log_msg({
             type: "event",
             msg: "<b>socket error:</b> <code>" + err + "</code>!"
         });
         socket.onclose = e => log_msg({
             type: "event",
             msg: "<em>socket" + (e.wasClean ? "" : " abruptly") +
                  " closed with code " + e.code + "</em>"
         });

         // request data to load
         socket.onopen = e => {
             prompt.disabled = false;
             var name = window.location.pathname.substring(1);
             var check = _ => send({ type: "status" });
             log_msg({
                 type: "event",
                 msg: "connected to <b>" + name + "</b> as <b>" + user + "</b>!"
             })
             check();
             setInterval(check, scint);


			 // video events
			 video.onpause = e => {
				 if (remote || video.ended)
					 return true;
				 send({
					 type: "pause",
					 val: video.currentTime,
				 });
			 };
			 video.onplay = e => {
				 if (remote || seeking)
					 return true;
				 send({
					 type: "play",
					 val: video.currentTime,
				 });
			 };
			 video.onseeking = e => {
				 if (remote)
					 return true;
				 seeking = true;
				 send({
					 type: "seek",
					 val: video.currentTime,
				 });
				 setTimeout(_ => seeking = false, bufwait);
			 };
			 video.onended = _ => {
				 remote = true;
				 video.src = "";
				 setTimeout(_ => send({ type: "next" }), 2000);
			 };
			 video.oncanplay = _ => {
				 if (video.paused) send({ type: "ready" });
			 };
			 video.onstalled = _ => send({ type: "pause", msg: user })

         };
        </script>
    {{ else }}
		<title>doji</title>
        <meta charset="utf-8" />
        <meta name="referrer" content="none" />
        <meta name="viewport" content="width=device-width" />
        <style>
		 body {
			 text-align: center;
             margin: 20vh auto 0 auto;
			 font-size: 1.5em;
             display: table;
		 }

		 #open {
			 background: blue;
			 border: 7.5px outset blue;
			 color: white;
			 padding: 0.5em;
			 display: inline-block;
			 text-decoration: none;
			 border-radius: 0.5em;
		 }

		 #open:hover { border-style: inset; }
        </style>
		<a href="{{ rndname }}"
		   title="create a doji room"
		   id="open">
			(☞ﾟヮﾟ)☞
		</a>
    {{ end }}
</html>
