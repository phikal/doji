<!doctype html>
<html>
	{{ with . }}
		<head lang="en">
			<title>doji [{{ .Key }}]</title>
			<meta charset="utf-8" />
			<meta name="referrer" content="none" />
			<meta name="viewport" content="width=device-width" />
			<link rel="stylesheet" type="text/css" href="./style.css" />
		</head>
		<body>
			<section>
				<video id="vid" controls preload
					   {{ if .Watching }}
					   src="/d/{{ .Key }}/{{ .Watching }}"
					   {{ end }}>
					Oh no! This browser doesn't support HTML video.
				</video>
			</section>
			<aside>
				<div id="log">
					<div id="users">
						{{ range .Users }}<span>{{ . }}</span>{{ end}}
					</div>
					<ul id="msg"></ul>
					<input type="text" id="prompt" disabled/>
				</div>
				<div id="other">
					<input type="text" id="ytdl" placeholder="ytdl-url" disabled />
					<ul id="video-list">
						{{ range .Videos }}<li>{{ . }}</li>{{ end }}
					</ul>
				</div>
			</aside>
						<script>
			 "use strict";

			 window.onload = function() {
				 const moffset = 0.38196601125; // maximal playback offset

				 const video = document.getElementById("vid"),
					   users = document.getElementById("users"),
					   prompt = document.getElementById("prompt"),
					   log = document.getElementById("msg"),
					   videos = document.getElementById("video-list"),
					   ytdl = document.getElementById("ytdl");

				 video.currentTime = {{ .Progress }};
				 video.volume = 0.25;
				 if ({{ not .Paused }}) video.play();

				 const user = document.cookie.replace(/(?:(?:^|.*;\s*)user\s*\=\s*([^;]*).*$)|^.*$/, "$1") ||
							  (Math.random() + 1).toString(36).substring(7);
				 document.cookie = "user=" + user;

				 function load_video(vid) {
					 var parser = document.createElement('a');
					 parser.href = video.src;

					 vid = "./d/" + window.location.pathname + "/" + vid;
					 if (vid && vid != "." + parser.pathname) { // TODO: make cleverer
						 video.src = vid;
						 video.load();
					 }
				 }

				 function load_status(data) {
					 while(videos.firstChild)
						 videos.removeChild(videos.firstChild);

					 if (data.vids)
						 data.vids.map(function(v) {
							 var vid = document.createElement("li");
							 vid.appendChild(document.createTextNode(v))
							 vid.onclick = function() {
								 socket.send(JSON.stringify({
									 type: "select",
									 msg: v
								 }));
							 }
							 videos.appendChild(vid)
						 })

					 while(users.firstChild)
						 users.removeChild(users.firstChild);
					 for (var u in data.users) {
						 var tag = document.createElement("span");
						 tag.appendChild(document.createTextNode(u))
						 users.appendChild(tag);
					 }

					 if (video.paused)
						 load_video(data.playing);

					 console.log(data.progress + " :: " + video.currentTime);
					 if (data.progress && video.currentTime != 0 &&
						 Math.abs(video.currentTime - data.progress) > moffset)
						 video.currentTime = data.progress;

					 if (data.paused)
						 video.pause();

					 prompt.disabled = ytdl.disabled = false;
					 prompt.style.background = prompt.style.background = "white";
				 }

				 function log_msg(msg) {
					 var l = document.createElement("li");
					 l.classList.add(msg.type);
					 switch(msg.type) {
						 case "talk":
							 l.innerHTML = "<b>" + msg.from + ":</b> ";
							 l.innerText += msg.msg;
							 break;
						 case "pause":
							 l.innerHTML = "<b>" + msg.from + "</b> paused the video";
							 break;
						 case "play":
							 l.innerHTML = "<b>" + msg.from + "</b> started playing the video";
							 break;
						 case "seek":
							 var s = msg.val;
							 if (!s || s < 1) break;
							 var hour = ~~(s / (60 * 60)),
								 min = ~~((s % (60 * 60)) / 60),
								 sec = s % 60;
							 sec = sec - (sec % 1)
							 l.innerHTML = "<b>" + msg.from + "</b> moved to " +
										   hour + ":" + min + ":" + sec;
							 break;
						 case "select":
							 l.innerHTML = "<b>" + msg.from + "</b> selected new video: <code>" + msg.msg + "</code>";
							 break;
						 case "event":
						 case "request":
							 l.innerHTML = msg.msg;
							 break;
						 default:
							 return;
					 }
					 log.appendChild(l);
					 log.scrollTop = log.scrollHeight;
				 }

				 var remote = false, seeking = false; /* hacked */
				 const socket = new WebSocket(location.href.replace(/https?:\/\//, "ws://") +
											  "/socket");
				 socket.onmessage = function (e) {
					 remote = true;
					 var msg = JSON.parse(e.data);
					 var timestamp = new Date().toLocaleTimeString();
					 switch(msg.type) {
						 case "pause":
							 if (msg.from != user)
								 video.pause();
							 break;
						 case "play":
							 if (msg.from != user && video.paused)
								 video.play();
							 break;
						 case "seek":
							 console.log(msg.val + " // " + video.currentTime);
							 if (msg.from != user && msg.val != undefined &&
								 Math.abs(msg.val - video.currentTime) > moffset)
								 video.currentTime = msg.val;
							 video.play();
							 break;
						 case "select":
							 load_video(msg.msg);
							 break;
						 case "status":
							 load_status(msg.data);
							 break;
					 }
					 log_msg(msg);
					 setTimeout(function() {
						 remote = false;
					 }, 100);
				 };

				 // video events
				 video.onstalled = video.onpause = function() {
					 if (remote || seeking) return;
					 socket.send(JSON.stringify({
						 type: "pause",
						 val: video.currentTime,
					 }));
				 }

				 video.onplay = function() {
					 if (remote || seeking) return;
					 socket.send(JSON.stringify({
						 type: "play",
						 val: video.currentTime,
					 }));
				 }

				 video.onseeked = function() {
					 if (remote) return;
					 seeking = true;
					 video.pause();
					 socket.send(JSON.stringify({
						 type: "seek",
						 val: video.currentTime
					 }));
					 setTimeout(function() {
						 seeking = false;
					 }, 100);
				 }

				 // input events
				 prompt.onkeypress = function(e) {
					 if (e.key == "Enter" && prompt.value) {
						 socket.send(JSON.stringify({
							 type: "talk",
							 msg: prompt.value.trim()
						 }));
						 prompt.value = "";
					 }
				 }

				 ytdl.onkeypress = function(e) {
					 if (e.key == "Enter" && ytdl.value) {
						 socket.send(JSON.stringify({
							 type: "request",
							 msg: ytdl.value.trim()
						 }));
						 ytdl.value = "";
					 }
				 }

				 // window events
				 window.onbeforeunload = function () {
					 socket.close();
				 }

				 // setup
				 socket.onerror = function(err) {
					 log_msg({
						 type: "event",
						 msg: "<b>socket error:</b> <code>" + err + "</code>!"
					 })
				 }

				 socket.onclose = function(e) {
					 log_msg({
						 type: "event",
						 msg: "<em>socket" + (e.wasClean ? "" : " abruptly") +
							  " closed with code " + e.code + "</em>"
					 })
				 }

				 // request data to load
				 function check() {
					 socket.send(JSON.stringify({ type: "status" }));
				 }

				 socket.onopen = function() {
					 var name = window.location.pathname.substring(1);
					 log_msg({
						 type: "event",
						 msg: "connected to <b>" + name + "</b> as <b>" + user + "</b>!"
					 })
					 check();
					 setInterval(check, 2500);
				 }
			 }
			</script>
		</body>
	{{ else }}
		<meta charset="utf-8" />
		<meta name="referrer" content="none" />
		<meta name="viewport" content="width=device-width" />
		<meta http-equiv="refresh" content="1; URL=..">
		<style>
		 body {
			 background: black;
			 margin: 20vh auto;
			 display: table;
			 font-family: monospace;
			 color: white;
			 font-size: 1.5em;
		 }
		</style>
		<em>quod periit, periit</em>
	{{ end }}
</html>
